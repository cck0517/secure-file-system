package client

import (
	"encoding/json"

	userlib "github.com/cs161-staff/project2-userlib"
	"github.com/google/uuid"

	// hex.EncodeToString(...) is useful for converting []byte to string

	// Useful for string manipulation
	// "strings"

	// Useful for formatting strings (e.g. `fmt.Sprintf`).
	"fmt"

	// Useful for creating new error messages to return using errors.New("...")
	"errors"

	// Optional.
	_ "strconv"
)

type User struct {
	Username string

	// You can add other attributes here if you want! But note that in order for attributes to
	// be included when this struct is serialized to/from JSON, they must be capitalized.
	// On the flipside, if you have an attribute that you want to be able to access from
	// this struct's methods, but you DON'T want that value to be included in the serialized value
	// of this struct that's stored in datastore, then you can use a "private" variable (e.g. one that
	// begins with a lowercase letter).

	Uuid    uuid.UUID         // NOT SURE IF THIS IS CORRECT DATATYPE
	Userkey userlib.DSSignKey //key used to sign the user information
	InvKey  userlib.PKEDecKey // key used to DECRYPT the invitation information
	//MapUUID     uuid.UUID         //  uuid of the map to all Invitations
	Sourcekey   []byte
	Salt        []byte
	UserInfoKey []byte // to encrypt userinfo as well as the MAP
	MapHMACkey  []byte // to HMAC the map info
	//SignInvkey userlib.DSSignKey  // key used to sign the invitation send to others
}

/* type Filemap struct {
	Map map[string]uuid.UUID
} */

type Medium struct {
	InvUUID uuid.UUID // uuid pointing to the invitation struct for a given file, for a given user
}

type FileMetadata struct {
	//UUID            uuid.UUID // this could be in userstruct
	AESKey          []byte    // AES key used to encrypt the file content
	HMACKey         []byte    // HMAC key
	FileContentUUID uuid.UUID // uuid points to Tail node file content in data store
}

// TODO: IS it safe to only change the location of the file instead of keys?
// TODO : add digital signature to invitations
type Invitation struct {
	Valid bool // whether this invitation is valid
	Owner bool // whether the one holding this invitation is the owner of the file
	//Receiver    string    // the username of the receiver
	FileUUID    uuid.UUID // The uuid that points to the filemetadata for this file
	InvListUUID uuid.UUID // the uuid that points to the invitation list for this user
	MetaAESkey  []byte
	MetaHMACkey []byte
	//Keybytes         []byte    // 16 bytes that are generated by the owner of the file using the owner's source key
	//Purpose          []byte    // 16 random bytes that are used to derive the file key using HASHKDF
	// Note that the result key, 64 bytes, corresponds to: MetaAES, MetaHMAC, fileAES, FileHMAC
}

type InvList struct { // this struct keeps info for all people being invited by a user
	Invitationmap map[string]uuid.UUID // map from username to invitation uuid
}

// Alex : created a new type struct file Content to implement a linked list structure for file contents
type contentNode struct {
	Text []byte    // the actual content
	Prev uuid.UUID // the uuid that points to the previous file content
}

// NOTE: The following methods have toy (insecure!) implementations.

func InitUser(username string, password string) (userdataptr *User, err error) {
	if username == "" {
		return nil, errors.New("Username cannot be empty!")
	}
	if password == "" {
		return nil, errors.New("Password cannot be empty!")
	}

	var userdata User
	userdata.Username = username

	// hash the username to get UUID
	username_bytes, err := json.Marshal(username)
	if err != nil {
		return nil, errors.New("Couldn't hash username!")
	}
	username_bytes = userlib.Hash(username_bytes)
	username_bytes = username_bytes[:16] // get the first 16 bytes of this hashed value

	userdata.Uuid, err = uuid.FromBytes(username_bytes)
	if err != nil {
		return nil, errors.New("Couldn't generate user uuid form bytes")
	}
	// check whether UUID exists
	_, ok := userlib.DatastoreGet(userdata.Uuid)
	if ok {
		return nil, errors.New("Username already exists or data has been tempered!") // report error when the uuid alread exists
	}

	// get argon2key hash
	var salt []byte
	salt = userlib.RandomBytes(4)
	userdata.Salt = salt
	password_bytes, err := json.Marshal(password)
	if err != nil {
		return nil, errors.New("Couldn't marshal password to bytes!")
	}
	userdata.Sourcekey = userlib.Argon2Key(password_bytes, salt, 16)

	// generate rsa digital signature key pairs for encrypting userdata
	var userPK userlib.DSVerifyKey
	userdata.Userkey, userPK, err = userlib.DSKeyGen()
	if err != nil {
		return nil, errors.New("Couldn't generate key pair!")
	}
	// store the public key for digital signature at keystore

	userlib.KeystoreSet(username+"userkey", userPK)

	// generate public and private key pair for invitations
	invPK, invSK, err10 := userlib.PKEKeyGen()
	if err10 != nil {
		return nil, err10
	}
	userdata.InvKey = invSK
	userlib.KeystoreSet(username+"invkey", invPK) // store the invitation key in keystoreget

	/* // generate key pair for digital dignature on invitation
		var verifyInvPK userlib.DSVerifyKey
	    userdata.SignInvkey, verifyInvPK, err = userlib.DSKeyGen()
		if err!=nil{
			return nil, err
		}
	    userlib.KeystoreSet(username+"sendkey", verifyInvPK) */

	// use HashKDF to generate an encyption byte
	purpose := "user info"
	purpose_byte, err := json.Marshal(purpose)
	if err != nil {
		return nil, errors.New("Couldn't Marshal!")
	}
	var key_userinfo []byte
	key_userinfo, err = userlib.HashKDF(userdata.Sourcekey, purpose_byte)
	if err != nil {
		return nil, errors.New("Couldn't Hash to key!")
	}
	AESkey_userinfo := key_userinfo[:16]
	HMACkey_mapinfo := key_userinfo[16:32]

	// init the User file map  UPDATE 04/10
	userdata.UserInfoKey = AESkey_userinfo
	userdata.MapHMACkey = HMACkey_mapinfo
	/* filemap := Filemap{Map: make(map[string]uuid.UUID)}
	encryptedFilemap, err11 := MEH(filemap, AESkey_userinfo, HMACkey_mapinfo)
	if err11 != nil {
		return nil, err11
	}
	MAPUUID := uuid.New()
	userdata.MapUUID = MAPUUID
	userlib.DatastoreSet(MAPUUID, encryptedFilemap) */

	//marshall the userstruct and AES ENCRYPT to get ciphertext

	var Ciphertext []byte
	Ciphertext, err = json.Marshal(userdata)
	if err != nil {
		return nil, errors.New("Couldn't Marshal!")
	}

	IV := userlib.RandomBytes(16)
	Ciphertext = userlib.SymEnc(AESkey_userinfo, IV, Ciphertext)

	//concatanate Ciphertext and Salt and sign the whole thing (the signature is 256 byte long)
	Cipher_Salt := append(Ciphertext, salt...)
	var dig_sig []byte
	dig_sig, err = userlib.DSSign(userdata.Userkey, Cipher_Salt)
	if err != nil {
		return nil, errors.New("Couldn't sign!")
	}
	//concatanate digital signature and the Cipher_salt and send to DataStore

	final := append(Cipher_Salt, dig_sig...)
	userlib.DatastoreSet(userdata.Uuid, final)

	return &userdata, nil
}

func GetUser(username string, password string) (userdataptr *User, err error) {
	var userdata User
	userdataptr = &userdata

	//first check user exists
	username_bytes, err := json.Marshal(username)
	if err != nil {
		return nil, errors.New("couldn't marshal username!")
	}
	username_bytes = userlib.Hash(username_bytes)
	username_bytes = username_bytes[:16]

	uuid_attempt, err := uuid.FromBytes(username_bytes)
	if err != nil {
		return nil, errors.New("couldn't generate UUID from bytes")
	}

	var CSD []byte // CSD stands for Ciphertext, salt, digital sig concatanated together
	var ok bool
	CSD, ok = userlib.DatastoreGet(uuid_attempt)
	if !ok {
		return nil, errors.New("Username does not exist or Userinfo has been tempered!")
	}

	// verify the digital signature
	// check if the size is big enough
	if len(CSD) < 260 {
		return nil, errors.New("CSD is too small!")
	}

	salt := CSD[len(CSD)-260 : len(CSD)-256] //Divide the CSD
	ds := CSD[len(CSD)-256:]
	Ciphertext := CSD[:len(CSD)-260]

	ds_PK, PK_exists := userlib.KeystoreGet(username + "userkey") // get PK for digital signature
	if !PK_exists {
		return nil, errors.New("User does not exists!")
	}
	CS := append(Ciphertext, salt...)
	err = userlib.DSVerify(ds_PK, CS, ds)
	if err != nil {
		return nil, errors.New("couldn't verify DS!")
	}
	// get AES key for decrption using provided password and salt
	password_bytes, err := json.Marshal(password)
	if err != nil {
		return nil, errors.New("couldn't marshal")
	}
	sourcekey := userlib.Argon2Key(password_bytes, salt, 16) //first get Source key

	purpose := "user info"
	purpose_byte, err := json.Marshal(purpose)
	if err != nil {
		return nil, errors.New("couldn't marshal")
	}
	var AESkey []byte
	AESkey, err = userlib.HashKDF(sourcekey, purpose_byte) //get AES key using the source key with the same exact purpose
	if err != nil {
		return nil, errors.New("couldn't hash AES key!")
	}
	AESkey = AESkey[:16]

	//Decrypt the Ciphertext and unmarshall it
	plaintext := userlib.SymDec(AESkey, Ciphertext)
	err = json.Unmarshal(plaintext, userdataptr)
	if err != nil {
		return nil, errors.New("couldn't unmarshal user struct!")
	}
	return userdataptr, nil
}

func (userdata *User) StoreFile(filename string, content []byte) (err error) {
	// Get the user first to Sync
	/* userdata, err = GetUser(userdata.Username, userdata.Password)
	if err != nil {
		return err
	} */
	// TODO: QUESTION: do we only need to check the map in user? Or we also need to check if the file exists in the Dataset
	/* var filemap Filemap
	err0 := getFilemap(userdata.MapUUID, &filemap, userdata.UserInfoKey, userdata.MapHMACkey)
	if err0 != nil {
		return err0
	} */
	mediumUUID, err00 := getMediumUUID(userdata.Uuid, filename)
	if err00 != nil {
		return err00
	}
	fileExist, InviteUUID, err000 := fromMediumGetInvUUID(mediumUUID, userdata.UserInfoKey, userdata.MapHMACkey)
	if err000 != nil {
		return err000
	}
	//InviteUUID, fileExist := filemap.Map[filename]
	// if file does not exist, create a new ContentNode and a new Filemetadata
	if !fileExist {
		// Use source key to get AES encrypt keys and HMAC keys
		purpose := filename // For a given file, simply use the file name as purpose
		purpose_byte, err1 := json.Marshal(purpose)
		if err1 != nil {
			return errors.New("couldn't marshal purpose byte!")
		}
		key, err2 := userlib.HashKDF(userdata.Sourcekey, purpose_byte)
		if err2 != nil {
			return errors.New("hashkdf error")
		}
		AESkeymeta := key[:16]       //AES key for meta is the first 16 byte
		HMACkeymeta := key[16:32]    //HMAC key for meta is the next 16 byte
		AESkeycontent := key[32:48]  //AES key for content is the next 16 byte
		HMACkeycontent := key[48:64] //HMAC key for content is the next 16 byte
		// create a new contentNode
		newContent := contentNode{
			Text: content,
			Prev: uuid.Nil, // As the Head node, the prev is simply nil
		}
		contentNodeUUID := uuid.New()                                             // create an UUID for this contentNode
		encrypted_content, err3 := MEH(newContent, AESkeycontent, HMACkeycontent) // marshal, encrypt, then MAC
		if err3 != nil {
			return errors.New("MEH error!")
		}
		userlib.DatastoreSet(contentNodeUUID, encrypted_content) // sent the contentnODE to datastore

		// Set up file metadata
		newMeta := FileMetadata{
			AESKey:          AESkeycontent,
			HMACKey:         HMACkeycontent,
			FileContentUUID: contentNodeUUID, // We are storing a new file, so the last node of file content is the headnode
		}
		encrypted_meta, err := MEH(newMeta, AESkeymeta, HMACkeymeta)
		if err != nil {
			return errors.New("MEH error!")
		}
		meta_uuid := uuid.New()                         // create a new uuid for metadata
		userlib.DatastoreSet(meta_uuid, encrypted_meta) // sent the metadata to datastore

		// TODO: filename needed to be encrypted
		// TODO: Encrypt filestruct' UUID, with user's public key and private key
		// create a new invlist
		newinvList := InvList{
			Invitationmap: make(map[string]uuid.UUID), // TODO: invList currently also uses FILEMETA AES key and file meta hmac key
		}
		invListencrypt, err8 := MEH(newinvList, AESkeymeta, HMACkeymeta)
		if err8 != nil {
			return errors.New("can't marshal invlist info")
		}
		invLUUID := uuid.New()
		userlib.DatastoreSet(invLUUID, invListencrypt) // store the brand new invlist into datastore
		newinvitation := Invitation{
			Valid:       true,
			Owner:       true,
			FileUUID:    meta_uuid,
			MetaAESkey:  AESkeymeta,
			MetaHMACkey: HMACkeymeta,
			InvListUUID: invLUUID,
		}

		/* encryptInv, err9 := MEH(newinvitation, AESkeymeta, HMACkeymeta)
		if err9 != nil {
			return errors.New("MEH error!")
		}
		newInviteUUID := uuid.New()
		userlib.DatastoreSet(newInviteUUID, encryptInv) // store new invitation beacuse this store is being called */

		// begin hybrid encription 2024/4/8
		PK, ok1 := userlib.KeystoreGet(userdata.Username + "invkey")
		if !ok1 {
			return errors.New("can't retrieve public key!")
		}

		encryptedInv, err9 := HybridEncrypt(PK, newinvitation, AESkeymeta, HMACkeymeta)
		if err9 != nil {
			return err9
		}
		newInviteUUID := uuid.New()
		userlib.DatastoreSet(newInviteUUID, encryptedInv)
		/* filemap.Map[filename] = newInviteUUID // update userdata with new filemap
		err10 := updateFilemap(userdata.MapUUID, filemap, userdata.UserInfoKey, userdata.MapHMACkey) */
		newMed := Medium{
			InvUUID: newInviteUUID,
		}
		err10 := UpdateMediumDataStore(newMed, mediumUUID, userdata.UserInfoKey, userdata.MapHMACkey)
		if err10 != nil {
			return err10
		}
	} else {
		// if file exists, overwrite the file
		inv, okk := userlib.DatastoreGet(InviteUUID) // first retrieve inivitation
		if !okk {
			return errors.New("Couldn't retrieve invitation data!")
		}
		// get the invitation struct UPDATE: 2024/4/8 Use the new hybrid method
		var invitation Invitation
		// get the verify key

		err5 := HybridDecrypt(userdata.InvKey, inv, &invitation)
		if err5 != nil {
			return errors.New("couldn't decrypt invitation struct")
		}
		/* err5 := MDU(inv, AESkeymeta, HMACkeymeta, &invitation) // get the filemetadata struct
		if err5 != nil {
			return errors.New("Couldn't verify then unmarshal file invitation")
		} */

		MetaDataUUID := invitation.FileUUID
		AESkeymeta := invitation.MetaAESkey
		HMACkeymeta := invitation.MetaHMACkey
		meta, ok := userlib.DatastoreGet(MetaDataUUID) // first retrieve Filemetadata
		if !ok {
			return errors.New("Couldn't retrieve Filemetadata!")
		}
		var metadata FileMetadata
		err4 := MDU(meta, AESkeymeta, HMACkeymeta, &metadata) // get the filemetadata struct
		if err4 != nil {
			return errors.New("Couldn't verify then unmarshal file metadata")
		}
		curUUID := metadata.FileContentUUID
		AESkeycontent, HMACkeycontent := metadata.AESKey, metadata.HMACKey
		var cur_raw_content []byte
		var cur_content contentNode
		var temp_uuid uuid.UUID
		for curUUID != uuid.Nil {
			cur_raw_content, ok = userlib.DatastoreGet(curUUID)
			if !ok {
				return errors.New("couldn't fetch file contentNode")
			}
			err = MDU(cur_raw_content, AESkeycontent, HMACkeycontent, &cur_content)
			if err != nil {
				return errors.New("Couldn't verify and decrypt contentNode")
			}
			temp_uuid = curUUID
			curUUID = cur_content.Prev
			userlib.DatastoreDelete(temp_uuid)
		} // iteratively delete all the contentNode of a file
		newContent := contentNode{ // create a new content node for this store
			Text: content,
			Prev: uuid.Nil, // As the Head node, the prev is simply nil
		}
		contentNodeUUID := uuid.New()                                            // create an UUID for this contentNode
		encrypted_content, err := MEH(newContent, AESkeycontent, HMACkeycontent) // marshal, encrypt, then MAC
		if err != nil {
			return errors.New("MEH error!")
		}
		userlib.DatastoreSet(contentNodeUUID, encrypted_content) // sent the contentnODE to datastore
		metadata.FileContentUUID = contentNodeUUID               // set the node pointer in filemetadata to be this newContentNode
		encrypted_meta, err := MEH(metadata, AESkeymeta, HMACkeymeta)
		if err != nil {
			return errors.New("MEH error!")
		}
		userlib.DatastoreSet(MetaDataUUID, encrypted_meta) // update the file metadata in datastore
		// There is no need to update invitation and invList when overwrite the file, only content in the file should change
		// Note that in this case we do not need to call update user because nothing in the user struct has been changed

		// setup the invitation struct and update it in datastore (This is being commented out because we don't need this)

		/* invitation.Valid = true
		newinvList := InvList{
			Invitationmap: make(map[string]uuid.UUID), // TODO: invList currently also uses FILEMETA AES key and file meta hmac key
		}
		invListencrypt, err6 := MEH(newinvList, AESkeymeta, HMACkeymeta)
		if err6 != nil {
			return errors.New("can't marshal invlist info")
		}
		invLUUID := uuid.New()
		userlib.DatastoreSet(invLUUID, invListencrypt) // store the brand new invlist into datastore
		invitation.InvListUUID = invLUUID
		encryptInv, err7 := MEH(invitation, AESkeymeta, HMACkeymeta)
		if err7 != nil {
			return errors.New("MEH error!")
		}
		userlib.DatastoreSet(InviteUUID, encryptInv) // update the new invitation beacuse this store is being called */
	}

	return nil
}

func (userdata *User) AppendToFile(filename string, content []byte) (err error) {
	/* metaUUID, fileExist := userdata.FileMap[filename] // get the UUID of the filemetadata

	if !fileExist {
		return errors.New("file not found in user's namespace")
	}

	// This block is used to safely retrieve the filemetadata
	var metaData FileMetadata

	// Use source key to get AES encrypt keys and HMAC keys
	purpose := filename // For a given file, simply use the file name as purpose
	purpose_byte, err := json.Marshal(purpose)
	if err != nil {
		return errors.New("couldn't marshal purpose byte!")
	}
	key, err := userlib.HashKDF(userdata.Sourcekey, purpose_byte)
	AESkeymeta := key[:16]    //AES key for meta is the first 16 byte
	HMACkeymeta := key[16:32] //HMAC key for meta is the next 16 byte

	meta, ok := userlib.DatastoreGet(metaUUID) // first retrieve Filemetadata
	if !ok {
		return errors.New("Couldn't retrieve Filemetadata!")
	}
	err = MDU(meta, AESkeymeta, HMACkeymeta, metaData) // get the filemetadata struct
	if err != nil {
		return errors.New("Couldn't verify then unmarshal file metadata")
	}
	*/
	if (content == nil) || (len(content) == 0) {
		return errors.New("content is empty")
	}
	var metaData FileMetadata
	AESkeymeta, HMACkeymeta, metaUUID, err1 := get_Meta(userdata, filename, &metaData)
	if err1 != nil {
		return errors.New("couldn't getmeta")
	}
	newContent := contentNode{
		Text: content,
		Prev: metaData.FileContentUUID,
	} // make a new content Node

	newContentUUID := uuid.New()
	/* marshedfile, err := json.Marshal(newContent) // marshal newContent to JSON
	if err != nil {
		return errors.New("ERROR: failed to marshal file")
	}

	encryptedFile, errr := EncThenMac(marshedfile, AESkey, HMACkey) // encrypt then HMAC the marshedfile
	if errr != nil {
		return errors.New("coudln't encrypt then mac!")
	} */
	encryptedFile, err2 := MEH(newContent, metaData.AESKey, metaData.HMACKey)
	if err2 != nil {
		return errors.New("couldn't MEH!")
	}

	userlib.DatastoreSet(newContentUUID, encryptedFile) // store the new content into Datastore

	metaData.FileContentUUID = newContentUUID // change the last contentNode recorded in filemetadata

	marshedmeta, err := json.Marshal(metaData) // marshal metadata to JSON
	if err != nil {
		return errors.New("ERROR: failed to marshal metadata")
	}

	//TODO: where is the key used to encrypt and HMAC file metadata (probably stored in user struct)
	encryptedmeta, errrr := EncThenMac(marshedmeta, AESkeymeta, HMACkeymeta) // encrypt then HMAC the marshed metadata
	if errrr != nil {
		return errors.New("couldn't encthenmac!")
	}

	userlib.DatastoreSet(metaUUID, encryptedmeta) // update the file meta data in datastore, Note that througout this append the only thing being send up to datastore is filemetadata and newcontent data
	return nil
}

func (userdata *User) LoadFile(filename string) (content []byte, err error) {
	// Get the user first to Sync
	/* userdata, err = GetUser(userdata.Username, userdata.Password)
	if err != nil {
		return nil, err
	} */
	var meta FileMetadata // pointer used to store the value for the filemetadata
	_, _, _, errr := get_Meta(userdata, filename, &meta)
	if errr != nil {
		return nil, errr
	}
	var currUUID uuid.UUID
	var cur_raw_content []byte
	var currNode contentNode
	var ok bool
	currUUID = meta.FileContentUUID
	for currUUID != uuid.Nil {
		cur_raw_content, ok = userlib.DatastoreGet(currUUID)
		if !ok {
			return nil, errors.New("couldn't fetch a file contentNode")
		}
		err = MDU(cur_raw_content, meta.AESKey, meta.HMACKey, &currNode)
		if err != nil {
			return nil, errors.New("couldn't verify and decrypt contentNode")
		}
		content = append(currNode.Text, content...)
		currUUID = currNode.Prev
	} // iteratively going from the tail of the nodelist to the front of the nodelist to get the whole content
	return content, nil
}

func (userdata *User) CreateInvitation(filename string, recipientUsername string) (
	invitationPtr uuid.UUID, err error) {
	var invitation Invitation
	AESkey, HMACkey, _, err1 := get_Inv(userdata, filename, &invitation) //use helper to get invitation struct
	if err1 != nil {
		return uuid.Nil, err1
	}

	newinvList := InvList{
		Invitationmap: make(map[string]uuid.UUID),
	}
	invListencrypt, err8 := MEH(newinvList, AESkey, HMACkey)
	if err8 != nil {
		return uuid.Nil, err8
	}
	invLUUID := uuid.New()
	userlib.DatastoreSet(invLUUID, invListencrypt) // store the brand new invlist into datastore
	newInvite := Invitation{
		Owner:       false,
		Valid:       true, // TODO: should this become true after called invite?
		MetaAESkey:  AESkey,
		MetaHMACkey: HMACkey,
		InvListUUID: invLUUID,
		FileUUID:    invitation.FileUUID,
	}
	// hyrbid encrypt the newInvite struct
	PKkey, ok := userlib.KeystoreGet(recipientUsername + "invkey")
	if !ok {
		return uuid.Nil, errors.New("can't retrieve public key!")
	}
	encryptedInv, err9 := HybridEncrypt(PKkey, newInvite, AESkey, HMACkey)
	if err9 != nil {
		return uuid.Nil, err9
	}
	newInviteUUID := uuid.New()
	userlib.DatastoreSet(newInviteUUID, encryptedInv) // store the new invitation into datastore
	// begin update the invitation list of the sender
	own_invL_uuid := invitation.InvListUUID
	var own_invL InvList
	raw_own_invL, okk := userlib.DatastoreGet(own_invL_uuid)
	if !okk {
		return uuid.Nil, errors.New("Couldn't retrieve invitationList data!")
	}
	err10 := MDU(raw_own_invL, AESkey, HMACkey, &own_invL)
	if err10 != nil {
		return uuid.Nil, err10
	}
	own_invL.Invitationmap[recipientUsername] = newInviteUUID // TODO: check

	encrypted_invL, err11 := MEH(own_invL, AESkey, HMACkey) //TODO :currently invlist is also encrypted using Meta keys, maybe invlist should also change location upon revoke?
	if err11 != nil {
		return uuid.Nil, errors.New("MEH error!")
	}
	userlib.DatastoreSet(own_invL_uuid, encrypted_invL) // store the new invlist into datastore

	return newInviteUUID, err
}

func (userdata *User) AcceptInvitation(senderUsername string, invitationPtr uuid.UUID, filename string) error {
	// Check if the recipient already has a file with the chosen filename
	/* var filemap Filemap
	err0 := getFilemap(userdata.MapUUID, &filemap, userdata.UserInfoKey, userdata.MapHMACkey) */
	mediumUUID, err0 := getMediumUUID(userdata.Uuid, filename)
	if err0 != nil {
		return err0
	}
	fileExist, _, err000 := fromMediumGetInvUUID(mediumUUID, userdata.UserInfoKey, userdata.MapHMACkey)
	if err000 != nil {
		return err000
	}
	if fileExist {
		return errors.New("file already exists in user's namespace")
	}
	/* if _, exists := filemap.Map[filename]; exists {
		return errors.New("file already exists in user's namespace")
	} */

	//TODO: Check for digital signature
	if invitationPtr == uuid.Nil {
		return errors.New("invitationPtr is nil!")
	}

	// The only thing to do here is to simply add invitation uuid into userFilemap
	newMed := Medium{InvUUID: invitationPtr}
	//filemap.Map[filename] = invitationPtr
	//success_update := updateFilemap(userdata.MapUUID, filemap, userdata.UserInfoKey, userdata.MapHMACkey)
	success_update := UpdateMediumDataStore(newMed, mediumUUID, userdata.UserInfoKey, userdata.MapHMACkey)
	if success_update != nil {
		return success_update
	}
	return nil
}

func (userdata *User) RevokeAccess(filename string, recipientUsername string) error {
	//step 1: go through the tree structure from the recipient's invitation list, change every invitation to invalid
	//step 2: get the file back and change file location (store once again)
	//step 3: Update the invitation struct, with new invList location for every user not in recipient's tree (DO RECURSIVELY)
	var invitation Invitation
	AESkey, HMACkey, _, err1 := get_Inv(userdata, filename, &invitation)
	//TODO: Check digital signature
	if err1 != nil {
		return err1
	}
	if !invitation.Owner {
		return errors.New("only the owner can revoke access") //Verify if self is the owner
	}
	ownInvLUUID := invitation.InvListUUID
	rawOwnInvL, ok1 := userlib.DatastoreGet(ownInvLUUID)
	if !ok1 {
		return errors.New("can't retrieve Invitation List")
	}
	var ownInvL InvList // get the invitation list of the owner
	err2 := MDU(rawOwnInvL, AESkey, HMACkey, &ownInvL)
	if err2 != nil {
		return err2
	}
	targetInvUUID, recipientExist := ownInvL.Invitationmap[recipientUsername]
	if !recipientExist {
		return errors.New("recipient not found in invitation list")
	}
	err3 := SetInvalid(targetInvUUID, AESkey, HMACkey) //step 1 (uses the helper function)
	if err3 != nil {
		return err3
	}
	delete(ownInvL.Invitationmap, recipientUsername) // delete the recipient from the invitation list
	//Before updateAccess, first upload everything to the cloud (only Invitation list here)
	encrypted_content, err4 := MEH(ownInvL, AESkey, HMACkey)
	if err4 != nil {
		return err4
	}
	userlib.DatastoreSet(ownInvLUUID, encrypted_content) // update the invList
	err5 := UpdateAccess(userdata, filename)             // Step 2 and 3
	if err5 != nil {
		return err5
	}
	return nil
}

// Jasper :Helper method used to decrpyt HMC-encrypted file
func decryptHMC(encryptedFile []byte, fileKey []byte) (content []byte) {
	AESkey := fileKey[:16]
	content = userlib.SymDec(AESkey, encryptedFile[:len(encryptedFile)-64])
	return content
}

// Alex: Helper method to first encrypt and then HMAC
// Given plaintext, an AES KEY AND a HMAC key, return the encrypt than HMAC
func EncThenMac(plaintext []byte, AESkey []byte, HMACkey []byte) (result []byte, err error) {
	IV := userlib.RandomBytes(16)
	ciphertext := userlib.SymEnc(AESkey, IV, plaintext)
	HMAC, err := userlib.HMACEval(HMACkey, ciphertext)
	if err != nil {
		return nil, errors.New("Couldn't generate HMAC!")
	}
	result = append(ciphertext, HMAC...)
	return result, nil
}

// Helper method : VerifyHMAC and then return the decrypted plaintext

func VerifyThenDec(cipherHMAC []byte, AESkey []byte, HMACkey []byte) (result []byte, err error) {
	length := len(cipherHMAC)
	// TODO: need to check if the length is larger than 64
	if length < 64 {
		return nil, errors.New("cipherHMAC too short")
	}
	oldHMAC := cipherHMAC[length-64:]
	ciphertext := cipherHMAC[:length-64]
	newHMAC, err := userlib.HMACEval(HMACkey, ciphertext)
	if err != nil {
		return nil, errors.New("Couldn't generate HMAC")
	}
	match := userlib.HMACEqual(oldHMAC, newHMAC)
	if !match {
		return nil, errors.New("Couldn't verify integrity!")
	}

	result = userlib.SymDec(AESkey, ciphertext)

	return result, nil
}

// helper that marshals a struct, encrypt it and then hmac, returns the final byte array
func MEH(s interface{}, AESkey []byte, HMACkey []byte) (result []byte, err error) {
	s_byte, err := json.Marshal(s)
	if err != nil {
		return nil, errors.New("Failed to Marshal!")
	}
	result, err = EncThenMac(s_byte, AESkey, HMACkey)
	if err != nil {
		return nil, errors.New("Failed to Encrypt then MAC!")
	}
	return result, nil
}

// helper that check integrity, decrypt and then unmarshal the struct, return the struct
func MDU(Ciphermac []byte, AESkey []byte, HMACkey []byte, ptr interface{}) (err error) {
	raw, err := VerifyThenDec(Ciphermac, AESkey, HMACkey)
	if err != nil {
		return errors.New("Couldn't verify and decrypt!")
	}
	err = json.Unmarshal(raw, ptr)
	if err != nil {
		return errors.New("Failed to Unmarshal struct")
	}
	return nil
}

// helper function that updates user struct information when something changed locally (this is not being Used anymore)
func update_user(userdata *User) (err error) {
	// use HashKDF to generate an encyption byte
	purpose := "user info"
	purpose_byte, err := json.Marshal(purpose)
	if err != nil {
		return errors.New("Couldn't marshal purpose")
	}
	var AESkey_userinfo []byte
	AESkey_userinfo, err = userlib.HashKDF(userdata.Sourcekey, purpose_byte)
	if err != nil {
		return errors.New("Couldn't derive userinfo AES key")
	}
	AESkey_userinfo = AESkey_userinfo[:16]

	//marshall the userstruct and AES ENCRYPT to get ciphertext

	var Ciphertext []byte
	Ciphertext, err = json.Marshal(userdata)
	if err != nil {
		return errors.New("Couldn't marshal user struct info")
	}

	IV := userlib.RandomBytes(16)
	Ciphertext = userlib.SymEnc(AESkey_userinfo, IV, Ciphertext)

	//concatanate Ciphertext and Salt and sign the whole thing (the signature is 256 byte long)
	Cipher_Salt := append(Ciphertext, userdata.Salt...)
	var dig_sig []byte
	dig_sig, err = userlib.DSSign(userdata.Userkey, Cipher_Salt)
	if err != nil {
		return errors.New("Couldn't Sign user struct info")
	}
	//concatanate digital signature and the Cipher_salt and send to DataStore

	final := append(Cipher_Salt, dig_sig...)
	userlib.DatastoreSet(userdata.Uuid, final)
	return nil
}

// helper func: Given a file name,user, and a struct pointer, return the metadata struct for this file into the struct pointer
func get_Meta(userdata *User, filename string, s *FileMetadata) (AESkeym []byte, HMACkeym []byte, id uuid.UUID, err error) {
	/* var filemap Filemap
	err0 := getFilemap(userdata.MapUUID, &filemap, userdata.UserInfoKey, userdata.MapHMACkey)
	if err0 != nil {
		return nil, nil, uuid.Nil, err0
	} */
	mediumUUID, err00 := getMediumUUID(userdata.Uuid, filename)
	if err00 != nil {
		return nil, nil, uuid.Nil, err00
	}
	fileExist, invUUID, err000 := fromMediumGetInvUUID(mediumUUID, userdata.UserInfoKey, userdata.MapHMACkey)
	if err000 != nil {
		return nil, nil, uuid.Nil, err000
	}
	//invUUID, fileExist := filemap.Map[filename] // get the UUID of the invitation data
	if !fileExist {
		return nil, nil, uuid.Nil, errors.New("file not found in user's namespace")
	}

	inv, okk := userlib.DatastoreGet(invUUID) // first retrieve inivitation
	if !okk {
		return nil, nil, uuid.Nil, errors.New("Couldn't retrieve invitation data!")
	}
	var invitation Invitation

	err5 := HybridDecrypt(userdata.InvKey, inv, &invitation)
	if err5 != nil {
		return nil, nil, uuid.Nil, errors.New("couldn't decrypt invitation struct")
	}
	AESkeymeta := invitation.MetaAESkey
	HMACkeymeta := invitation.MetaHMACkey
	/* v := invitation.Valid
	if !v {
		return nil, nil, uuid.Nil, errors.New("access denied")
	} */
	metaUUID := invitation.FileUUID
	meta, ok := userlib.DatastoreGet(metaUUID) // first retrieve Filemetadata
	if !ok {
		return nil, nil, uuid.Nil, errors.New("Couldn't retrieve Filemetadata!")
	}
	err = MDU(meta, AESkeymeta, HMACkeymeta, s) // get the filemetadata struct
	if err != nil {
		return nil, nil, uuid.Nil, errors.New("Couldn't verify then unmarshal file metadata")
	}
	return AESkeymeta, HMACkeymeta, metaUUID, nil
}

// same as get_Meta, just here tweaked a few bit for getting the invitation data
func get_Inv(userdata *User, filename string, s *Invitation) (AESkeym []byte, HMACkeym []byte, id uuid.UUID, err error) {
	/* invUUID, fileExist := userdata.FileMap[filename] // get the UUID of the invitation data
	if !fileExist {
		return nil, nil, uuid.Nil, errors.New("file not found in user's namespace")
	}
	// Use source key to get AES encrypt keys and HMAC keys
	purpose := filename // For a given file, simply use the file name as purpose
	purpose_byte, err := json.Marshal(purpose)
	if err != nil {
		return nil, nil, uuid.Nil, errors.New("couldn't marshal purpose byte!")
	}
	key, err := userlib.HashKDF(userdata.Sourcekey, purpose_byte)
	AESkeymeta := key[:16]    //AES key for meta is the first 16 byte
	HMACkeymeta := key[16:32] //HMAC key for meta is the next 16 byte

	inv, okk := userlib.DatastoreGet(invUUID) // first retrieve inivitation
	if !okk {
		return nil, nil, uuid.Nil, errors.New("Couldn't retrieve invitation data!")
	}
	// get the invitation struct TODO: currently using metadatakeys

	err5 := MDU(inv, AESkeymeta, HMACkeymeta, s) // get the invitation struct
	if err5 != nil {
		return nil, nil, uuid.Nil, errors.New("Couldn't verify then unmarshal file invitation")
	} */
	// UPDATE 2024/4/8
	/* var filemap Filemap
	err0 := getFilemap(userdata.MapUUID, &filemap, userdata.UserInfoKey, userdata.MapHMACkey)
	if err0 != nil {
		return nil, nil, uuid.Nil, err0
	} */
	mediumUUID, err00 := getMediumUUID(userdata.Uuid, filename)
	if err00 != nil {
		return nil, nil, uuid.Nil, err00
	}
	fileExist, InviteUUID, err000 := fromMediumGetInvUUID(mediumUUID, userdata.UserInfoKey, userdata.MapHMACkey)
	if err000 != nil {
		return nil, nil, uuid.Nil, err000
	}
	//InviteUUID, fileExist := filemap.Map[filename]
	if !fileExist {
		return nil, nil, uuid.Nil, errors.New("file not found in user's namespace")
	}
	inv, okk := userlib.DatastoreGet(InviteUUID) // first retrieve inivitation
	if !okk {
		return nil, nil, uuid.Nil, errors.New("Couldn't retrieve invitation data!")
	}
	// get the invitation struct UPDATE: 2024/4/8 Use the new hybrid method

	err5 := HybridDecrypt(userdata.InvKey, inv, s)
	if err5 != nil {
		return nil, nil, uuid.Nil, errors.New("couldn't decrypt invitation struct")
	}
	// CHECK If the user has access or has been revoked
	// TODO : is it enough to just check here for access?
	v := s.Valid
	if !v {
		return nil, nil, uuid.Nil, errors.New("access denied")
	}
	AESkeymeta := s.MetaAESkey
	HMACkeymeta := s.MetaHMACkey

	return AESkeymeta, HMACkeymeta, InviteUUID, nil
}
func AsyncMEH(receiver string, s interface{}) (encrypted []byte, err error) { //TODO
	//key, ok := userlib.KeystoreGet(receiver + "invkey")
	//if !ok {
	//return nil, errors.New("can't retrieve public key!")
	//}
	return nil, nil

}

// Helper function that encrypt the invitation using the receiver's public key
// Hybrid Encrypt since RSA encryption does not support very long plaintext.
// After encryption, append encrypted symkey to the end of the whole thing , sign the wholething
// and append the signature to the very end
func HybridEncrypt(recipientPublicKey userlib.PKEEncKey, data interface{}, AESkeymeta []byte, HMACkey []byte) (DataHMACSymkey []byte, err error) {
	// Marshal the data into a []byte
	jsonData, err := json.Marshal(data)
	if err != nil {
		return nil, fmt.Errorf("error marshaling data: %v", err)
	}

	/* // Generate a random symmetric key for AES encryption
	symKey := userlib.RandomBytes(16) // 128 bits for AES */ // Use the same key for a givn file

	// Encrypt the actual data (jsonData) with the symmetric key
	IV := userlib.RandomBytes(16) // AES requires a 16-byte IV
	encryptedData := userlib.SymEnc(AESkeymeta, IV, jsonData)

	// Encrypt the symmetric key with the recipient's RSA public key
	encryptedSymKey, err1 := userlib.PKEEnc(recipientPublicKey, append(AESkeymeta, HMACkey...))
	if err1 != nil {
		return nil, fmt.Errorf("error encrypting symmetric key: %v", err)
	}
	HMAC, err5 := userlib.HMACEval(HMACkey, encryptedData)
	if err5 != nil {
		return nil, errors.New("Couldn't generate HMAC!")
	}
	DataHMACSymkey = append(encryptedData, HMAC...)
	DataHMACSymkey = append(DataHMACSymkey, encryptedSymKey...)

	return DataHMACSymkey, nil
}

func HybridDecrypt(recipientPrivateKey userlib.PKEDecKey, rawdata []byte, data interface{}) error {
	// Decrypt the symmetric key with the recipient's RSA private key
	length := len(rawdata)
	if (length - 64 - 256) < 0 {
		return errors.New("invalid data length")
	}

	encryptedData, HMAC, encryptedSymKey := rawdata[:length-320], rawdata[length-320:length-256], rawdata[length-256:]
	symTotalKey, err := userlib.PKEDec(recipientPrivateKey, encryptedSymKey)
	if err != nil {
		return fmt.Errorf("error decrypting symmetric key: %v", err)
	}
	symKey, HMACkey := symTotalKey[:16], symTotalKey[16:]
	newHMAC, err33 := userlib.HMACEval(HMACkey, encryptedData)
	if err33 != nil {
		return errors.New("Couldn't generate HMAC")
	}
	match := userlib.HMACEqual(HMAC, newHMAC)
	if !match {
		return errors.New("Couldn't verify integrity!")
	}
	// Decrypt the data with the symmetric key
	decryptedData := userlib.SymDec(symKey, encryptedData)

	// Unmarshal the decrypted data back into the original data structure
	err = json.Unmarshal(decryptedData, data)
	if err != nil {
		return fmt.Errorf("error unmarshaling decrypted data: %v", err)
	}

	return nil
}

// Helper function that recursively deletes the invitation struct for every revoked user on the invitation tree
func SetInvalid(InvUUID uuid.UUID, AESkey []byte, HMACkey []byte) error {
	inv, okk := userlib.DatastoreGet(InvUUID) // retrieve inivitation
	if !okk {
		return errors.New("Couldn't retrieve invitation data!")
	}
	/* inv_sliced := inv[:len(inv)-256]
	//TODO : Check for digital signature
	decryptedData := userlib.SymDec(AESkey, inv_sliced)
	var invitation Invitation
	err1 := json.Unmarshal(decryptedData, &invitation)
	if err1 != nil {
		return fmt.Errorf("error unmarshaling decrypted data: %v", err1)
	} */
	var invitation Invitation
	err1 := UpperLevelHybridDe(inv, AESkey, HMACkey, &invitation)
	if err1 != nil {
		return err1
	}
	//TODO: for now, simply delete the inivtation struct when revoking
	InvLUUID := invitation.InvListUUID
	userlib.DatastoreDelete(InvUUID) // delete the current invitation
	var InvL InvList
	rawInvL, ok1 := userlib.DatastoreGet(InvLUUID)
	if !ok1 {
		return errors.New("can't get invitation list data")
	}
	err2 := MDU(rawInvL, AESkey, HMACkey, &InvL)
	if err2 != nil {
		return err2
	}
	if len(InvL.Invitationmap) == 0 {
		return nil
	} else {
		var err error
		for _, invUUID := range InvL.Invitationmap {
			err = SetInvalid(invUUID, AESkey, HMACkey)
			if err != nil {
				return err
			}
		}
		return nil
	}

}
func UpdateAccess(userdata *User, filename string) error {
	// Use source key to get AES encrypt keys and HMAC keys
	purpose := filename // For a given file, simply use the file name as purpose
	purpose_byte, err1 := json.Marshal(purpose)
	if err1 != nil {
		return errors.New("couldn't marshal purpose byte!")
	}
	key, err2 := userlib.HashKDF(userdata.Sourcekey, purpose_byte)
	if err2 != nil {
		return errors.New("hashkdf error")
	}
	AESkeymeta := key[:16]
	HMACkeymeta := key[16:32]
	AESkeycontent := key[32:48]
	HMACkeycontent := key[48:64]
	// create a new contentNode
	content, err3 := userdata.LoadFile(filename) // get the content using Load function
	if err3 != nil {
		return err3
	}
	newContent := contentNode{
		Text: content,
		Prev: uuid.Nil, // As the Head node, the prev is simply nil
	}
	contentNodeUUID := uuid.New()                                             // create an UUID for this contentNode
	encrypted_content, err3 := MEH(newContent, AESkeycontent, HMACkeycontent) // marshal, encrypt, then MAC
	if err3 != nil {
		return errors.New("MEH error!")
	}
	userlib.DatastoreSet(contentNodeUUID, encrypted_content) // sent the contentnODE to datastore

	// Set up file metadata
	newMeta := FileMetadata{
		AESKey:          AESkeycontent,
		HMACKey:         HMACkeycontent,
		FileContentUUID: contentNodeUUID, // We are storing a new file, so the last node of file content is the headnode
	}
	encrypted_meta, err := MEH(newMeta, AESkeymeta, HMACkeymeta)
	if err != nil {
		return errors.New("MEH error!")
	}
	meta_uuid := uuid.New()                         // create a new uuid for metadata
	userlib.DatastoreSet(meta_uuid, encrypted_meta) // sent the metadata to datastore

	var invitation Invitation // get invitation for the current file
	_, _, InvUUID, err4 := get_Inv(userdata, filename, &invitation)
	if err4 != nil {
		return err4
	}
	var meta FileMetadata
	_, _, old_meta_id, errr := get_Meta(userdata, filename, &meta)
	if errr != nil {
		return errors.New("couldn't get Metadata!")
	}
	err5 := UpdateFileUUID(meta_uuid, InvUUID, userdata.Username, AESkeymeta, HMACkeymeta) // Update all legit user's invitation struct with the new meta_uuid
	if err5 != nil {
		return err5
	}
	// Begin deleting things

	userlib.DatastoreDelete(old_meta_id) // delete the old meta struct
	curUUID := meta.FileContentUUID
	var cur_raw_content []byte
	var cur_content contentNode
	var temp_uuid uuid.UUID
	var ok bool
	for curUUID != uuid.Nil {
		cur_raw_content, ok = userlib.DatastoreGet(curUUID)
		if !ok {
			return errors.New("couldn't fetch file contentNode")
		}
		err = MDU(cur_raw_content, AESkeycontent, HMACkeycontent, &cur_content)
		if err != nil {
			return errors.New("Couldn't verify and decrypt contentNode")
		}
		temp_uuid = curUUID
		curUUID = cur_content.Prev
		userlib.DatastoreDelete(temp_uuid)
	} // iteratively delete all the contentNodes of a file
	return nil

}
func UpdateFileUUID(newMetaID uuid.UUID, InvUUID uuid.UUID, name string, AESkey []byte, HMACkey []byte) error {
	//TODO: Check Digital Signature!!
	inv, okk := userlib.DatastoreGet(InvUUID) // retrieve inivitation
	if !okk {
		return errors.New("Couldn't retrieve invitation data!")
	}
	var invitation Invitation
	err1 := UpperLevelHybridDe(inv, AESkey, HMACkey, &invitation)
	if err1 != nil {
		return err1
	}
	InvLUUID := invitation.InvListUUID
	var InvL InvList
	rawInvL, ok1 := userlib.DatastoreGet(InvLUUID)
	if !ok1 {
		return errors.New("can't get invitation list data")
	}
	err2 := MDU(rawInvL, AESkey, HMACkey, &InvL)
	if err2 != nil {
		return err2
	}

	invitation.FileUUID = newMetaID // update the file meta id
	PK, ok2 := userlib.KeystoreGet(name + "invkey")
	if !ok2 {
		return errors.New("can't retrieve public key!")
	}

	encryptedInv, err3 := HybridEncrypt(PK, invitation, AESkey, HMACkey)
	if err3 != nil {
		return err3
	}
	userlib.DatastoreSet(InvUUID, encryptedInv) //update in the cloud
	if len(InvL.Invitationmap) == 0 {
		return nil
	}
	var err error
	for recipient, id := range InvL.Invitationmap {
		err = UpdateFileUUID(newMetaID, id, recipient, AESkey, HMACkey)
		if err != nil {
			return err
		}
	}
	return nil
}

// Not Used Anymore
/* func getFilemap(MapUUID uuid.UUID, s *Filemap, AESkey []byte, HMACkey []byte) error {
	rawbyte, ok := userlib.DatastoreGet(MapUUID)
	if !ok {
		return errors.New("cant get rawbyte from datastore")
	}
	err1 := MDU(rawbyte, AESkey, HMACkey, s)
	if err1 != nil {
		return err1
	}
	return nil
} */
// Not used anymore
/* func updateFilemap(MapUUID uuid.UUID, filemap Filemap, AESkey []byte, HMACkey []byte) error {
	rawbyte, err0 := MEH(filemap, AESkey, HMACkey)
	if err0 != nil {
		return err0
	}
	userlib.DatastoreSet(MapUUID, rawbyte)
	return nil
} */

func getMediumUUID(userUUID uuid.UUID, filename string) (result uuid.UUID, err error) {
	user_byte, err1 := json.Marshal(userUUID)
	if err1 != nil {
		return uuid.Nil, errors.New("couldn't marshal user uuid to byte!")
	}
	file_byte, err2 := json.Marshal(filename)
	if err2 != nil {
		return uuid.Nil, errors.New("couldn't marshal filename to byte!")
	}
	final := append(user_byte, file_byte...)
	hash := userlib.Hash(final)
	result, err = uuid.FromBytes(hash[:16])
	if err != nil {
		return uuid.Nil, err
	}
	return result, nil
}
func fromMediumGetInvUUID(MediumUUID uuid.UUID, AESkey []byte, HMACkey []byte) (exists bool, InvUUID uuid.UUID, err error) {
	rawbyte, ok := userlib.DatastoreGet(MediumUUID)
	if !ok {
		return false, uuid.Nil, nil
	}
	var med Medium
	err1 := MDU(rawbyte, AESkey, HMACkey, &med)
	if err1 != nil {
		return false, uuid.Nil, err1
	}
	InvUUID = med.InvUUID
	return true, InvUUID, nil
}
func UpdateMediumDataStore(med Medium, MedUUID uuid.UUID, AESkey []byte, HMACkey []byte) error {
	rawbyte, err0 := MEH(med, AESkey, HMACkey)
	if err0 != nil {
		return err0
	}
	userlib.DatastoreSet(MedUUID, rawbyte)
	return nil
}
func UpperLevelHybridDe(rawdata []byte, AESkey []byte, HMACk []byte, s *Invitation) error {
	length := len(rawdata)
	encryptedData, HMAC := rawdata[:length-320], rawdata[length-320:length-256]

	symKey, HMACkey := AESkey, HMACk
	newHMAC, err33 := userlib.HMACEval(HMACkey, encryptedData)
	if err33 != nil {
		return errors.New("Couldn't generate HMAC")
	}
	match := userlib.HMACEqual(HMAC, newHMAC)
	if !match {
		return errors.New("Couldn't verify integrity!")
	}
	// Decrypt the data with the symmetric key
	decryptedData := userlib.SymDec(symKey, encryptedData)

	// Unmarshal the decrypted data back into the original data structure
	err := json.Unmarshal(decryptedData, s)
	if err != nil {
		return fmt.Errorf("error unmarshaling decrypted data: %v", err)
	}

	return nil
}
